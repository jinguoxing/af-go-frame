package af_go_frame

import (
    "context"
    "errors"
    "github.com/google/uuid"
    baseOptions "github.com/jinguoxing/af-go-frame/core/options"
    "github.com/jinguoxing/af-go-frame/core/registry"
    "golang.org/x/sync/errgroup"
    "os"
    "os/signal"
    "sync"
    "syscall"
    "time"
)

// AppInfo is application context value.
type AppInfo interface {
    ID() string
    Name() string
    //    Version() string
    //    Metadata() map[string]string
    //Endpoint() []string
}

type App struct {
    opts       options
    commonOpts baseOptions.CommonOptions
    ctx        context.Context
    cancel     func()
    mu         sync.Mutex
    instance   *registry.ServiceInstance
}

// New create an application lifecycle manager.
func New(opts ...Option) *App {
    o := options{
        ctx:              context.Background(),
        sigs:             []os.Signal{syscall.SIGTERM, syscall.SIGQUIT, syscall.SIGINT},
        registrarTimeout: 10 * time.Second,
        stopTimeout:      10 * time.Second,
    }
    if id, err := uuid.NewUUID(); err == nil {
        o.id = id.String()
    }
    for _, opt := range opts {
        opt(&o)
    }
    //if o.logger != nil {
    //   // log.SetLogger(o.logger)
    //}
    ctx, cancel := context.WithCancel(o.ctx)
    return &App{
        ctx:    ctx,
        cancel: cancel,
        opts:   o,
    }
}

func (a *App) ID() string {
    return a.opts.id
}

func (a *App) Name() string {
    return a.opts.name
}

// Endpoint returns endpoints.
func (a *App) Endpoint() []string {
    if a.instance != nil {
        return a.instance.Endpoints
    }
    return nil
}

// Run executes all OnStart hooks registered with the application's Lifecycle.
func (a *App) Run() error {
    instance, err := a.buildInstance()
    if err != nil {
        return err
    }
    a.mu.Lock()
    a.instance = instance
    a.mu.Unlock()
    eg, ctx := errgroup.WithContext(NewContext(a.ctx, a))
    wg := sync.WaitGroup{}
    for _, srv := range a.opts.servers {
        srv := srv
        eg.Go(func() error {
            <-ctx.Done() // wait for stop signal
            stopCtx, cancel := context.WithTimeout(NewContext(a.opts.ctx, a), a.opts.stopTimeout)
            defer cancel()
            return srv.Stop(stopCtx)
        })
        wg.Add(1)
        eg.Go(func() error {
            wg.Done()
            return srv.Start(NewContext(a.opts.ctx, a))
        })
    }
    wg.Wait()
    if a.opts.registrar != nil {
        rctx, rcancel := context.WithTimeout(ctx, a.opts.registrarTimeout)
        defer rcancel()
        if err := a.opts.registrar.Register(rctx, instance); err != nil {
            return err
        }
    }
    c := make(chan os.Signal, 1)
    signal.Notify(c, a.opts.sigs...)
    eg.Go(func() error {
        select {
        case <-ctx.Done():
            return nil
        case <-c:
            return a.Stop()
        }
    })
    if err := eg.Wait(); err != nil && !errors.Is(err, context.Canceled) {
        return err
    }
    return nil
}

// Stop gracefully stops the application.
func (a *App) Stop() error {
    a.mu.Lock()
    instance := a.instance
    a.mu.Unlock()
    if a.opts.registrar != nil && instance != nil {
        ctx, cancel := context.WithTimeout(NewContext(a.ctx, a), a.opts.registrarTimeout)
        defer cancel()
        if err := a.opts.registrar.Deregister(ctx, instance); err != nil {
            return err
        }
    }
    if a.cancel != nil {
        a.cancel()
    }
    return nil
}

func (a *App) buildInstance() (*registry.ServiceInstance, error) {
    //endpoints := make([]string, 0, len(a.opts.endpoints))
    //for _, e := range a.opts.endpoints {
    //    endpoints = append(endpoints, e.String())
    //}
    //if len(endpoints) == 0 {
    //    for _, srv := range a.opts.servers {
    //        if r, ok := srv.(transport.Endpointer); ok {
    //            e, err := r.Endpoint()
    //            if err != nil {
    //                return nil, err
    //            }
    //            endpoints = append(endpoints, e.String())
    //        }
    //    }
    //}
    return &registry.ServiceInstance{
        ID:   a.opts.id,
        Name: a.opts.name,
        //Version:   a.opts.version,
        //Metadata:  a.opts.metadata,
        // Endpoints: endpoints,
    }, nil
}

type appKey struct{}

// NewContext returns a new Context that carries value.
func NewContext(ctx context.Context, s AppInfo) context.Context {
    return context.WithValue(ctx, appKey{}, s)
}

// FromContext returns the Transport value stored in ctx, if any.
func FromContext(ctx context.Context) (s AppInfo, ok bool) {
    s, ok = ctx.Value(appKey{}).(AppInfo)
    return
}
